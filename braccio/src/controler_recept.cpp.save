//#include <socket.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <vector>
#include <fcntl.h>
#include <errno.h>
#include <dirent.h>

#include "ros/ros.h"
#include "braccio/creation.h"
#include "std_msgs/String.h"
#include "std_msgs/Bool.h"

using namespace std;

#define PORT 4242
#define SERIAL_PORT "/dev/ttyACM1"
#define MOVE_DIR "./move/"

class Braccio_robot{
    private:
        int serial_port; // port série controlant la base
				char* serial_port_s;
        ros::NodeHandle* n;
        ros::ServiceClient createur_client;
        braccio::creation  createur_serveur;
        ros::Publisher joueur_pub;
        ros::Subscriber joueur_sub;
        int client_sd;
        bool sequence; // Une séquence est-elle en cours ?
        void free_sequence();

    public:
        vector<string> mouvements;
        int init();
        Braccio_robot(int _client_sd, ros::NodeHandle* _n, char* _serial_port);
        ~Braccio_robot();
        int pilotage(char commande[]);
        int creation(char commande[]);
        int pause();
        void sleep();
};

void Braccio_robot::free_sequence(){
    sequence = false;
}

Braccio_robot::~Braccio_robot(){
    sleep();  
}

void Braccio_robot::sleep(){
    pause();
    std_msgs::String dodo;
    dodo.data = "sleep";
    sequence = true;
    joueur_pub.publish(dodo);
    while(sequence);
}

int Braccio_robot::pause(){
    char initialisation[7] = {1, 0,0, 0,0, 0, 0};
    return pilotage(initialisation);
}

Braccio_robot::Braccio_robot(int _client_sd, ros::NodeHandle* _n, char* _serial_port){
    serial_port_s = _serial_port;
    client_sd = _client_sd;
    sequence = false;
    n = _n;
    createur_client = n->serviceClient<braccio::creation>("creation");
    joueur_pub      = n->advertise<std_msgs::String>("mouvement",10);
    joueur_sub      = n->subscribe("termine", 10, free_sequence);
}

int Braccio_robot::init(){
    int res = pause(); // mise en pause des moteurs
    if(res){ // en cas d'erreur
        // Demander la mise en position initiale du bras
        std_msgs::String msg;
        msg.data = "initial";
        sequence = true;
        joueur_pub.publish(msg);
        // Attendre la terminaison du mouvement
        while(sequence);
        return res;
    }
    
    // charger la liste des mouvements depuis le dossier correspondant
    DIR *dir = opendir(MOVE_DIR);    
    if(dir != nullptr){
        struct dirent *diread;
        while((diread = readdir(dir)) != nullptr){
            if(diread->d_name[0] != '.'){
                mouvements.push_back(diread->d_name);
            }
        }
        closedir(dir);
    } else {
        ROS_ERROR("Error opening directory : %s",MOVE_DIR);
        return -1;
    }
    serial_port = open(serial_port_s, O_RDWR);
    if(serial_port < 0){
        ROS_ERROR("Failed opening serial port %s"serial_port);
        res = -2;
    }
    return res;
}

void Braccio_robot::creation(char commande[]){
    string new_move(commande + 2);    
    //Envoyer la commande à pypot de créer un nouveau mouvement (via un service) 
    createur_serveur.request.move_name = new_move;
    createur_serveur.request.duration = (uint8_t)commande[1];
    createur_client.call(createur_serveur);
    bool success = createur_serveur.response.success;
    string result;
    if(success){
        result.append("success");
        mouvements.push_back(new_move);
    } else {
        result.append("failure");
    }
    write(client_sd, result.data(), result.length());
}

int Braccio_robot::pilotage(char commande[]){
    // Envoyer la commande à l'arduino
    int res = write(serial_port, commande + 1, 4);

    if(res < 0){
        string msg("lose base motors");
        write(client_sd, msg.data(), msg.length());
    }

    bool controlOeuf;
    if(commande[5]){
        controlOeuf = true;
    } else {
        controlOeuf = false;
    }

    if(joueSequence > 0 && sequence == false){
        sequence = //#include <socket.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <strings.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <vector>
#include <fcntl.h>
#include <errno.h>
#include <dirent.h>

#include "ros/ros.h"
#include "braccio/creation.h"
#include "std_msgs/String.h"
#include "std_msgs/Bool.h"

using namespace std;

#define PORT 4242
#define SERIAL_PORT "/dev/ttyACM1"
#define MOVE_DIR "./move/"

class Braccio_robot{
    private:
        int serial_port; // port série controlant la base
				char* serial_port_s;
        ros::NodeHandle* n;
        ros::ServiceClient createur_client;
        braccio::creation  createur_serveur;
        ros::Publisher joueur_pub;
        ros::Subscriber joueur_sub;
        int client_sd;
        bool sequence; // Une séquence est-elle en cours ?
        void free_sequence();

    public:
        vector<string> mouvements;
        int init();
        Braccio_robot(int _client_sd, ros::NodeHandle* _n, char* _serial_port);
        ~Braccio_robot();
        int pilotage(char commande[]);
        int creation(char commande[]);
        int pause();
        void sleep();
};

void Braccio_robot::free_sequence(){
    sequence = false;
}

Braccio_robot::~Braccio_robot(){
    sleep();  
}

void Braccio_robot::sleep(){
    pause();
    std_msgs::String dodo;
    dodo.data = "sleep";
    sequence = true;
    joueur_pub.publish(dodo);
    while(sequence);
}

int Braccio_robot::pause(){
    char initialisation[7] = {1, 0,0, 0,0, 0, 0};
    return pilotage(initialisation);
}

Braccio_robot::Braccio_robot(int _client_sd, ros::NodeHandle* _n, char* _serial_port){
    serial_port_s = _serial_port;
    client_sd = _client_sd;
    sequence = false;
    n = _n;
    createur_client = n->serviceClient<braccio::creation>("creation");
    joueur_pub      = n->advertise<std_msgs::String>("mouvement",10);
    joueur_sub      = n->subscribe("termine", 10, free_sequence);
}

int Braccio_robot::init(){
    int res = pause(); // mise en pause des moteurs
    if(res){ // en cas d'erreur
        // Demander la mise en position initiale du bras
        std_msgs::String msg;
        msg.data = "initial";
        sequence = true;
        joueur_pub.publish(msg);
        // Attendre la terminaison du mouvement
        while(sequence);
        return res;
    }
    
    // charger la liste des mouvements depuis le dossier correspondant
    DIR *dir = opendir(MOVE_DIR);    
    if(dir != nullptr){
        struct dirent *diread;
        while((diread = readdir(dir)) != nullptr){
            if(diread->d_name[0] != '.'){
                mouvements.push_back(diread->d_name);
            }
        }
        closedir(dir);
    } else {
        ROS_ERROR("Error opening directory : %s",MOVE_DIR);
        return -1;
    }
    serial_port = open(serial_port_s, O_RDWR);
    if(serial_port < 0){
        ROS_ERROR("Failed opening serial port %s"serial_port);
        res = -2;
    }
    return res;
}

void Braccio_robot::creation(char commande[]){
    string new_move(commande + 2);    
    //Envoyer la commande à pypot de créer un nouveau mouvement (via un service) 
    createur_serveur.request.move_name = new_move;
    createur_serveur.request.duration = (uint8_t)commande[1];
    createur_client.call(createur_serveur);
    bool success = createur_serveur.response.success;
    string result;
    if(success){
        result.append("success");
        mouvements.push_back(new_move);
    } else {
        result.append("failure");
    }
    write(client_sd, result.data(), result.length());
}

int Braccio_robot::pilotage(char commande[]){
    // Envoyer la commande à l'arduino
    int res = write(serial_port, commande + 1, 4);

    if(res < 0){
        string msg("lose base motors");
        write(client_sd, msg.data(), msg.length());
    }

    bool controlOeuf;
    if(commande[5]){
        controlOeuf = true;
    } else {
        controlOeuf = false;
    }

    if(joueSequence > 0 && sequence == false){
        sequence = 